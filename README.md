# Тестовое задание для Embedded разработчика

## Описание
Данный проект представляет собой эмуляцию микроконтроллера с базовым функционалом GPIO и MQTT-коммуникацией. Ниже приведены требования и задачи по доработке существующего функционала.

## Задание

### Требования
1. Реализовать управление RGB светодиодом через MQTT:
   - Добавить поддержку пинов 3, 5, 6 для управления RGB светодиодом (каждый пин отвечает за свой цвет)
   - Реализовать обработку команды `set_rgb` в формате JSON:
     ```json
     {
       "command": "set_rgb",
       "red": 255,
       "green": 100,
       "blue": 50
     }
     ```
   - Значения для каждого цвета должны быть в диапазоне 0-255
   - При получении команды необходимо:
     - Проверить корректность входных данных
     - Установить соответствующие значения на пинах
     - Опубликовать подтверждение в топик `embedded/pins/state`

2. Добавить поддержку аналогового входа:
   - Реализовать функцию `analogRead(pin)` для чтения аналоговых значений
   - Добавить эмуляцию аналогового датчика температуры на пине A0
   - Значение температуры должно генерироваться случайным образом в диапазоне 20-30°C
   - Публиковать значение температуры в топик `embedded/sensors/temperature` каждые 5 секунд

3. Реализовать обработку ошибок:
   - Добавить валидацию всех входящих MQTT сообщений
   - Публиковать ошибки в топик `embedded/errors`
   - Обрабатывать случаи некорректных значений пинов и команд

### Ожидаемый результат
1. Корректная работа с RGB светодиодом через MQTT
2. Периодическая публикация данных с аналогового датчика температуры
3. Обработка и логирование ошибок
4. Сохранение существующего функционала (GPIO, MQTT, перезапуск)

### Критерии оценки
1. Корректность реализации
2. Качество кода и структура
3. Обработка ошибок и edge cases
4. Эффективность использования ресурсов
5. Читаемость и документация кода

## Реализованный функционал

### GPIO функции
В приложении реализованы следующие функции, имитирующие работу с GPIO микроконтроллера:

1. `pinMode(pin, isOutput)` - установка режима работы пина
   - `pin` - номер пина (uint8_t)
   - `isOutput` - режим работы (true - выход, false - вход)

2. `digitalRead(pin)` - чтение состояния пина
   - `pin` - номер пина (uint8_t)
   - Возвращает текущее состояние пина (true - HIGH, false - LOW)

3. `digitalWrite(pin, value)` - запись состояния пина
   - `pin` - номер пина (uint8_t)
   - `value` - значение для записи (true - HIGH, false - LOW)

### MQTT функционал
- Подключение к MQTT брокеру (EMQX)
- Автоматическое переподключение при потере связи
- Публикация состояния пинов в топик `embedded/pins/state`
- Подписка на команды в топике `embedded/control`
- Поддержка команд:
  - `restart` - перезапуск контроллера

### Дополнительные функции
- Обработка переменных окружения для конфигурации
- Логирование операций
- Задержки для снижения нагрузки на CPU
- Механизм перезапуска контроллера

## Запуск приложения

### Требования
- Docker и Docker Compose
- Make (опционально)

### Через Makefile
```bash
# Сборка и запуск
make up

# Остановка
make down

# Просмотр логов
make logs
```

### Через Docker Compose напрямую
```bash
# Запуск
docker-compose up -d

# Остановка
docker-compose down

# Просмотр логов
docker-compose logs -f
```

## Конфигурация
Приложение использует следующие переменные окружения:
- `MQTT_HOST` - адрес MQTT брокера (по умолчанию: localhost)
- `MQTT_PORT` - порт MQTT брокера (по умолчанию: 1883)
- `MQTT_USERNAME` - имя пользователя MQTT
- `MQTT_PASSWORD` - пароль MQTT

## Структура проекта
```
.
├── main.cpp          # Основной код приложения
├── Dockerfile        # Конфигурация Docker
├── docker-compose.yml # Конфигурация Docker Compose
├── Makefile          # Упрощенные команды для работы с Docker
└── README.md         # Документация
``` 